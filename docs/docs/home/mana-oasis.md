---
title: Lorem ipsum dolor sit amet
status: new
---


# Project Mana Oasis

## Philosophy

今后我的主要方向和梦想项目，是设计创造与搭建场景世界，用想象力、渲染技术和音乐具现化脑海中的世界。游戏开发我也会做，但只是为了辅助场景搭建，实现一些场景的功能，比如写一个传送门脚本，但这不是我的主要focus。一个人一辈子的精力是有限的，我主要只做渲染和着色、建模与设计。

未来mana oasis的定位于是变得十分简单了，它就是一个探索类游戏，以探索和感受世界为主，因为主体是一个极其庞大的世界场景。每个大陆按照不同场景划分为很多部分，由大陆世界地图连接起来，场景间通过交通工具连接。世界，则由许多这样的大陆组成，大陆之间没有路可以走，不是通过空间连接的，而是通过时空传送门。只有当在一个大陆收集齐了所有场景的碎片，组合出一个水晶球（每个大陆的专属水晶球，如紫水晶），才能开启传送门，前往它所打开的新大陆。

游戏的主要内容，是逛世界，感叹世界场景的奇妙，听音乐享受氛围。同时，场景中藏着许多古书，是把一些PDF复刻到游戏中，用一种独特的电子方式展示出来的。等于说，游戏本身是一个大的图书馆，可以在游戏中听音乐看书，挖掘文明宝藏和知识。

在游戏中，单纯的探索世界，其实是会很快厌倦的，因此都是以战斗形式、玩法、剧情等其他主要因素去推动。当然，我一个人不可能有时间精力去做出一部完整的3A大作，更不可能写一本小说。因此，要明确，我们的主线是探索逛世界，而这个探索的核心在于meditation，要把世界做的非常有意境非常精致完美，让人愿意停在一个地方，配合一些简单的游戏元素和音乐去进行冥想，以达到精神情感上的某种收获，以及认知上的某种新理解。我们的核心不是玩法，也不是战斗，也不是故事rush主线，更不是通过任务要让玩家去走马观花的到处跑世界地图，却没有在地图上任何地方真正的静下来停留，而是要以环境世界本身去留住玩家，就像是一个VRChat的温馨小世界一样，没事就过去看看，在某个屋子里待上几个小时，可能是和别人聊天， 也可能是自己做什么事情，看书冥想之类的。所以我们的游戏，可能更接近于VRChat的感觉，而不是Hogwarts/Lies of P这样的RPG作品，我们的宗旨是没有主线才是最好的主线，每个玩家感受到的主线内容都应该是不一样的，同一个场景，对不同人也应该有不同的情感承载和意义。所以最终，我们不需要多么复杂的战斗系统，多么深度的剧情故事，反而是更需要一些提示类的线索内容，各种地上的笔记，墙上的字什么的，又或者是某一幅画某样物品，来让每个人遐想和感受他们所能想到的东西。

本地Mana-Oasis/Reference文件夹下面的所有

主城及家族名为Amethestia 艾米希斯提亚 紫水晶之泪

旋转木马 摩天轮 白沙滩 迷宫宫殿 红地毯 古典旋转楼梯 宴会大厅 大型空荡音乐演奏厅 魔法大门 世界树 水果乐园 甜点天堂 时光倒流回廊 烛光餐厅 东方神殿 女神像圣地 天空之城 通天塔 玩具世界 彩虹村 能量圈 传送门 时钟楼 深海神殿 黄金废墟 魔法树林 古代遗迹 星光宇宙 银河楼梯 古书库 宝石走廊 粉墙白幕布少女卧室 风铃西瓜冰镇饮料海边咖啡厅

所有精美可爱的二次元人物手办，买原作的3D模型文件，静态的即可，导入到游戏里收藏展示。很可能买不到源文件的版权，那就自己3D扫描，再导入到blender里手工降噪，修整好了再导入游戏。尽量参考三次元的手办，做自己原创的3D模型，静态模型只有一个pose，会比做animation的keyframe简单很多。

anime-style夏日沙滩+碧蓝的海+白云

各种galgame的精美CG 场景CG

pink home

圣魔之血的那个画面

niccori魔法使的咖啡厅，巧克力，甜点

可塑性记忆的夜晚游乐园

kamakura

道路素材，做成ground layer

水体和VFX参考 FluidNinja LIVE

世界七大奇迹 宇宙奇观 各种自然奇观（双彩虹，极光，海市蜃楼，morning glory云彩，火焰龙卷风，超大的星球月亮等等）

glacier crevasse，蓝洞

推特上那个animetic照片的摄影师的作品，kagaya的作品

大量收集pixiv上的图图，付费下载一些画师的作品，准备放在游戏的艺术展览馆里，用stream流读取

UFO飞碟，三个用parent-child关系悬空连在一起，有红色的灯闪光亮着和飞机一样，飞碟有自己的重力场，相当于一个重力球，靠近一定距离后玩家就不受地面重力控制了。三个飞碟只有中间那个是主飞碟，用来载客的，两边的两个飞碟与之成一定角度旋转（像盘子在桌子上打圈一样），从而产生磁场提供动力。

湖边的很长的连排的木制栈道，像是木头版本的外滩一样，每隔一段距离护栏下都有地面台灯，连起来形成夜景美丽浪漫的湖畔景色。

美丽的城市夜景，tower mansion，雪乃家的内室，全画幅透明玻璃窗，bird view俯瞰整个城市灯火。

把我住过的每个房间或房子建模出来，放在Restopia的探索室里，包括高中学校教室，大学寝室等等。现在的魁北克房间，搬走之前建模出来。

NameTBD  // 把所有收藏的古典音乐，肖邦莫扎特勃拉姆斯李斯特柴可夫斯基舒伯特门德尔松德沃夏克巴赫等等全部放进来。做几个巴洛克宫殿，放满他们的照片和传记。

Port Lavina  // 专门存放二次元美女梦中情人完美女神的 高分辨率图片展示美术馆 是一座很高的灯塔 层数很高 黑雪姬 亚斯娜 Gift白丝！推特各种图。。。

***DJ Master  // 做一个中小型的DJ音乐厅用来播放动漫音乐，玩家可以自己导入电脑本地的音乐CD听，可作为KTV使用

***Octave Land // 做一个大型的专业音乐厅大剧院，有超赞的音响配置和灯光效果和回声，一个人的空荡大剧院，带舞台和幕布和大屏幕。

以上两个场景，加上一个屏幕，用来展示音乐可视化效果，这是个亮点功能，类似于网易云app的可视化动态音效，有几种主题可以选，颜色和粒子特效很炫酷。实现方式参考这里：https://zhuanlan.zhihu.com/p/92971717  （代码读取音乐频域的数值，写入一张256像素宽度的贴图，最后配一个shader）

Restopia的女仆和人物，要用最完美的二次元美女来打造，是完美的理想型妹子，美如天仙。lovelive-sunshine咖啡色头发+蓝色短袖衫+短裙+棕色靴子+白丝，还有我最爱的黑雪姬，以及淡粉色连衣裙+粉色高跟鞋+白丝的艾米利亚搭配，还有那种超赞的淡紫色头发+淡紫色学园制服短裙+淡紫色白丝。那种特别纯白的，并且在冷日光下略有点偏蓝和偏紫的白丝是最美的白丝。参考图片收藏。
补充：哥特式的黑羽亚夜子，哥特式连衣裙+双马尾+红色公主鞋+白丝黑丝，以及换拖鞋。

===================================================
2021更新游戏主线：西方哲学史，将游戏世界作为一个讲解哲学学说的媒介，以探索和解谜的形式引人思考。游戏主旨是为了表达理性与感性的世界观，再现对世界的各种感受。

游戏主线：玩家进入游戏，来到一个神秘的世界，充满了mana，某个神秘的人在临走前将整个世界委托给了玩家，这世界虽然充满了mana，但却因为几十年前经历了一场未知的巨大灾难，导致世界上的原有的人类和可爱物种都灭绝了，只剩下非生命非意识体（世界本身的建筑物植物房子什么的，以及野外的怪物和魔物）没有受到丝毫影响（可能是受到了其他宇宙的人的大规模生物净化魔法），还有Restopia由于在结界的保护下没有受到影响，所以你的女仆们都在。你作为玩家，要在探索这个世界的同时，开垦荒地建造城市，并用祖传的魔法孕育新的文明和生命（其实是AI），这些AI的智力和成长会受到你的对话以及魔法的影响（实际上后台去调用siri这种机器学习的模型让AI学会对话），另一方面，你的主要任务是在这个世界中，探索曾经的人们所留下的信息，包括前人们对于幸福的日记，对于哲学的感悟记录，古文书，包括前人们在消失前留下的线索，通过这些线索和发现，去还原和找到这些生命被消灭的真相，是谁是什么导致了他们消失，为什么要做这么残忍的事，为什么Restopia没有受到影响，有没有其他幸存者，究竟是谁委托给了你这个世界，上个主人是谁（女仆们并不知道），这个世界从何而来，世界的本质是什么，这个世界到底有什么秘密，由此展开你的探险和冒险，由此展开这个庞大的世界观和各种故事线。最终，玩家发现了真相，找到了消灭这个宇宙所有生命意识体的真凶，本想要前往那个宇宙去报仇，但却面临着一个两难抉择，由于相隔几万光年，一旦踏上了外宇宙旅行，时间的流动就会加快，即使玩家报了仇回来了，原先的世界也已经过了几亿年早就不在了，失去的东西太多了代价太大了，而如果玩家选择了去报仇，等见到真凶的时候，却意外从真凶的口中得知了一个更惊天的秘密，了解了它消灭生命体的初衷是好意的，然后各种。。。。

当你拓展了游戏内的世界文明，开发了新的城市和地图，这些数据会保存在玩家的电脑本地。在登录的时候，玩家可以选择默认登录自己本机的这个游戏存档，但也可以输入一个IP地址远程登录到朋友的游戏存档里面去（朋友那边必须要先登录才行），然后和朋友一起探索他建造的世界，他可能有更豪华的跑车什么的。玩家也可以在登录界面选择邀请朋友连线到自己电脑本地的存档，点击邀请按钮后，界面会生成一个IP地址，只要把这个IP发给朋友，等待朋友连接就可以了，这样就可以实现一个chat oasis的功能。

关于save load和login logout的场景，做一个独立的虚无空间，用类似时空宇宙和黑洞做skybox，就是很小的场景，入口是一个传送门，通过一座架空的桥梁通往前方几百米的一个大祭坛，祭坛要做的大一点壮观一点，差不多和篮球场那么大。玩家在游戏中选择save的时候，就将玩家和画面切换传送到该场景的传送门处，然后玩家需要跑到祭坛的地方触发祭坛里的魔法球，选择save则游戏数据会被保存，可能会需要两三秒时间，这期间展示魔法球的动画表示正在save，save之后玩家可以跑回入口处，通过传送门回到之前在游戏内的场景和坐标，也可以在魔法球处选择exit游戏，点了exit后魔法球释放另一个效果，然后退出游戏。
玩家每次login进入游戏的时候，都会出现在祭坛的地方，这是进入mana-oasis的主入口，然后不能动，必须要在魔法球里做一个选择，要么开始新游戏，要么load之前的某个存档，load当然也有伴随的魔法球特效，load之后就可以动了，再跑到传送门进入该存档。save load当然是通过序列化来完成的，存储到本地的数据库或者云端，存档的上限设置为7，最多只能有7份存档。
如果是new game的话，通过传送门进入的第一个场景就是Restopia，初始坐标为Restopia的传送门。注意传送门永远是成对出现的，in pair，不能单独存在。Restopia是一座浮游岛，有自己的白天黑夜skybox，并不总是黑夜。只有save load的虚无空间是极夜。

collider会自动判断碰撞而触发物理，因此collider无法重合，OnCollisionEnter(), OnCollisionStay(), OnCollisionExit()可以实现除了碰撞以外的逻辑，但是碰撞的物理法则本身无法避免和取消，无法重合。
而trigger(叫sensor更准确)只会在检测到碰撞时发出一个信号，需要开发者自己用OnTriggerEnter去捕捉到信号并做处理，不过这也给了我们更大的自由度。比如场景里的房子，就可以设置一个范围稍大的trigger，当玩家碰撞到trigger后，则认为她可能会要进入房子，因此就可以预先load房间内部的场景了，同时还可以做一些物理法则做不到的事情，比如穿透墙壁。OnTriggerEnter(), OnTriggerStay(), OnTriggerExit()

通常都是选择加一个刚体，来自动实现物理法则。除非你想完全自由的自己控制一个物体的运动，或是让它违反物理法则，那么这个时候就要用kinematic自己处理了。kinematic只是用来指明go的运动是否受physics引擎控制，与该物体属于哪种collision是完全两回事，不要混在一起。不管是不是kinematic，都有normal和trigger这两种collision模式。比较复杂的是，我们要搞清楚哪些场景下collision会触发什么事件，这个具体参考官方文档的collision矩阵，以及在project settings的Collision Matrix config中进行设置。

对于scene的environment，场景的地形石头建筑物墙壁什么的，确定不会移动：
static，no rigidbody，不规则草木什么的用convex mesh collider否则用primitive collider, non-trigger，non-kinematic
由于这些是static collider，没有刚体，所以OnCollisionXXX不会在这些物体上触发，要从另一方collider（移动的character）判断。从Unity5开始，static collider在scene中移动也不会再有performance惩罚了，所以动态的草木也可以是static的。

对于scene的非环境物体，可以被受力和移动的，比如地上一个箱子：
非static，标准刚体，标准collider（非kinematic非trigger），尽量用primitive（实在复杂用convex mesh），必要时可以挂脚本处理OnCollisionXXX。

对于门这种，平时是静止的，必要时又要动的；或者是台灯这种有switch开关的物体，平时是静止的，必要时要on/off的
非static，标准刚体，Kinematic collider，非trigger，挂脚本处理OnCollisionXXX来控制移动，或者是播放移动的动画，或是开灯。只要脚本里没有移动该物体，该物体就会保持静止。

对于有动画的骨骼人物或怪物，用compound primitive colliders，具体用Ragdoll Wizard来生成。
非static，不同身体部位有单独的刚体，默认都是Kinematic collider（为了动画），非trigger。挂脚本处理OnCollision，如果是被车撞飞什么的，要在代码里把IsKinematic设成false，使其成为一个正常的受physics影响的物体，落地后再设回true，具体分情况处理。
过程参见https://learn.unity.com/tutorial/creating-ragdolls-2019#5e1c555dedbc2a0410472a3b
但是问题是，kinematic rigidbody collider没有办法和static collider碰撞，所以玩家可以随意穿墙钻地，一个解决方案是在character外面再套一层正常的刚体collider（capsule），不过要保证玩家的身体组织kinematic collider不会和这个自己的刚体collider碰撞，第二个解决方案是在project settings的physics中设置enable kinematic static pairs，然后在玩家的脚本里处理OnCollisionXXX，再有的解决方案就非常复杂了，涉及到具体怎么实现一个更高级的controller，这个去参考商店的付费素材研究。character controller做好了以后，再加上root motion和inverse kinematics，完成到一个流畅的程度，然后再看下官方文档关于performance优化这一块，不要让player占据太多内存，最后在商店购买Dynamic Bone插件，对character的服饰挂件和头发添加physics，使得头发什么的能随着玩家animate而实时的逼真的动态效果。
玩家的骨骼动画有基本的动作就可以了，不要试图什么都模仿现实，太复杂了，有基本的走跑坐站躺吃喝+表情、扭头、攻击、防御、施法等动画即可，其他手臂和手的动作比如现实里拿东西什么的这种不要一个个做，太多了，可以只做一个滑动和点击菜单的动画，作为通用的动作，然后呢，具体的是拿东西也好切菜也好拧瓶盖也好发动汽车也好，都用游戏中的全息图像投影出的UI菜单来代替，UI里列出可操作的动作按钮，character只要去滑动和点击按钮即可。有个例外是开门关门，因为这个动作太普遍了，自己做动画，但是由于各种门把手形状都不同，所以折衷一下就做个类似手推的意念施法动作来开关门。
只要在unity的settings中设置好玩家layer和其他layer的collision matrix，KCC的motor就会自动去判断哪些layer可以碰撞，不用操心。有特殊情况的collider的话，在playerController的Misc中设置IgnoredColliders就行了。记住，玩家的IgnoredCollider和相机的IgnoredCollider是分开的，要分别设置。

一个灵活的玩家controller都是kinematic的，这样才有更高的自由度能游泳能爬梯子，但是kinematic的意思是告诉Unity不要用PhysX，所有的物理我都自己处理，哪怕玩家走进墙内了我开发者也是知道的，我会自己处理不用你PhysX操心，这些需要非常高超的编程技术。现阶段先用一个简单的capsule collider代替玩家，把世界架构搭出来，后期再处理character。注意一点，由于玩家character本身（或玩家身上的某个child刚体）是要挂载FPS或TPS相机的，为了保证相机跟随的流畅，玩家人物的motion必须要非常平滑，所以要把被挂载的刚体的interpolate设置打开，使其能用插值平滑推断每一瞬间的position，并且相机要在LateUpdate中更新，这样就不会有jitter卡的情况了，起码build了以后不会，事实上，相机就用Cinemachine就好了（cm的collider extension，把collide against设成environment的layer，并不是什么障碍物都要forward相机的，然后ignore player tag），对于驾驶车辆的FPS/TPS，记得在Cinemachine里加上噪音来模仿车的小颠簸，还要记得另外加两个小相机，一个是导航地图minimap，还有一个是反向的用来渲染车辆后视镜（左右都加），如果是行驶中碰到障碍物或路上的凸起，车辆的刚体会自动触发物理碰撞，导致比较大的颠簸，这个效果不要用噪音做，而是用Cinemachine Impulse来实现，具体参考文档和example的scene，爆炸导致相机shake也这么做。

对于需要检测玩家是否进入范围的，但是可以穿墙的，比如invisible的边界，用static trigger collider，不加刚体，用onTriggerEnter检测。

collider设置好之后，加上Physic Material按不同的物体材质设置，同一个刚体可能有多个collider，每个collider可以单独设置那部分的physic material，或者直接把Physic Material放在刚体上，那么所有的collider都会用同一个Physic Material。注意，两个go相撞时，不一定要两边都加上Physic Material，只有其中一方有也可以的，没加的那一方相当于是用的系统默认的physic material，也就是弹力为0，摩擦力为0.6。如果不是特殊的材质比如冰面这种，不用特意去加，冰面摩擦力为0，橡胶弹力为1摩擦力为1，水中的河床摩擦力为1，其他的基本上不用改，弹力很少会用到的。

当collision发生时，如果物体的移动速度极快，同时又是用PhysX引擎控制的（非kinematic），控制碰撞反弹的逻辑可能会跟不上，所以引擎的fixedUpdate还会更新几帧，会导致物体的一部分穿进墙内，这时候要在rigidbody的constraints设置下面freeze掉position（如果希望物体slide滑动那么rotation也freeze掉），物体就绝不会穿墙了。只有在处理特别高速的物体时才需要设置这个，比如赛车什么的，一般不用。而kinematic这种自己代码控制的物体，与此无关。此外记住，这种physX控制的运动，只要是每帧更新的东西都要写在fixedUpdate方法里，比如用Time.deltaTime每一物理帧更新位置什么的（千万别用Time.fixedDeltaTime，那是常数而不是delta时间），而Update方法里只用来判断玩家Input，根据逻辑一次性地AddForce，或是设置一次性的初始速度。再比如，控制物体弹跳，如果收到Input的空格键了，就在update里设一下jump的flag为true，但不要去真的去调用jump，真正的jump要放在fixedUpdate里来做，做之前把flag设回false。
为什么要用FixedUpdate呢？想象一下，如果FPS很低，Update更新的很慢，一个刚体的移动要是在update里更新，自然也会随之变慢，不符合realistic的物理法则，而fixedUpdate每0.02秒跑一次，无视游戏的FPS，这样物体运动才更合理，这种情况下，由于update很慢，update更新一次时，fixedUpdate已经更新很多次了，而每个frame是跟着每个update进行render的，所以update渲染的只会是经过多次fixedUpdate后的那个最终结果。但是如果update和fixedUpdate速度差太多，每次render的时候fixedupdate都已经更新了很多次，物体移动了很远的距离，在渲染时就会感觉物体每帧是在瞬间移动，就和网络lag的时候画面卡一样，这时就必须要优化FPS，如果不是FPS的问题而是物体本身就是移动太快了（或者你为了精准物理而手动把Time.fixedDeltaTime设置的特别小），那怎么办呢，简单，在rigidbody下面找到Interpolate的设置并选上interpolate（一般不用extrapolate选项，那个是用来猜测物体移动位置的，只有当物体固定方向匀速稳定运动时才会用），让physX自动的线性插值平滑，只不过这时你在画面上看到的物体的移动更新实际上是比真实的physX更新要滞后的。

检测collision最有效的办法是，对不同的物体进行归类并标注自定义的layer，并在项目中设置好哪些layer之间需要检测碰撞。用layer的好处是unity会自动过滤掉不相关layer的go，大幅度提高性能。这比起通过go的tag来检测要快好几倍，因为tag是需要做字符串比较来判断的。
另一个优化是，保证collider是比较简单的，通常是把children上的primitive组合起来成为compound collider，哪怕实在要用mesh collider也要设置成convex。要知道，Raycasting against a mesh collider is really expensive. 在使用raycast检测碰撞时，提前规定好射程，不要用mathf.Infinity，并且，Be specific on what the ray should hit and always try to specify a layer mask on the raycast function.

Non-kinematic rigid bodies will ignore the hierarchy. If you make one rigid body a child of another and translate the parent. Then the child will NOT move with the parent. The child’s transform will update so that it remains in place in world space. If you want to couple rigid bodies you need to use joints.

Shirley现在没法换装，她的裙子是放在mesh里面的，用不了VRoidHub的素材，只能等以后学了Blender再用blender修改。
所以，Shirley先作为暂时的主角。后期的时候，还是自己用VRoidStudio做一个主角，配置各种Hub上的素材衣服袜子之类的，头发难不要紧，直接用Hub现成的收费素材。难点在于VRoidStudio不知道怎么做shader，可能需要导入blender或unity再做shader。到了后期，Shirley就只当作Restopia的女仆来用，可以做女仆长。她的动画保持简洁就可以了。

Mark and highlight the whole Unity Manual = twice! twice!

overview and skim all scripts in the Unitywiki scripts section, also highlight

整理github utilities的library

目前阶段还在探索，先用DRP完成一切雏形，基本成型了以后，再把项目升级为HDRP，参考官方upgrade指南。画质和素材调优什么的，后期统一做，现在先focus在Unity开发本身上以及写脚本上。

游戏内做一个键盘自定义的功能，玩家可以自行更改某些功能的hotkey，画一个模拟的键盘，玩家可以拖动不同的键。
劲乐团！！！！！！在游戏内做一个劲乐团出来！！！！七个按键的！！！3D版本的！！！单独做个场景加载，为了键盘反应的性能。

加一个存档点savepoint的功能，但是不同于单机游戏的存档功能（因为mana时间是与现实同步的）。savepoint是一个房间或传送门，可以让玩家传送到过去的某个时间点的与当前相同的位置，进入一个嵌套的空间（时间倒退了），但mana时间还是正常流动，玩家必须在一定时间内离开该空间。这个可以用来存储一些有纪念意义的场景，比如圣诞节和特殊event之类的。

关于FPS/TPS controller，对应的Jasper Flick的Movement系列的教程比较难，需要专门花一周多时间，这块先放着，最好先等买了那个素材然后试着写一写自己的controller，然后再回过头来看会理解地更快一些，整合到自己的代码里去，最后再把wiki页面上的CharacterController和Physics部分的脚本过一遍整合进来。相机不要钻研太细，TPS就把Cinemachine玩透了就OK，FPS就直接挂人物头上。

登录界面+登录音乐，以故事的形式进入游戏，主题是，来寻找到“我”吧，被选中的人。“我”是谁？其实我就是这个世界，你存在的同时，我也在凝视着你，“我”是你的人生价值。无论在游戏还是现实世界，人只活一次，真正有意义的，是去寻找mana，寻找爱的回忆，所以才叫做mana oasis。mana是一切的基础和重点。

游戏入口的场景是玩家拥有的一座城堡，是老家就叫做mana-oasis，城堡很壮观，有多栋楼，每栋楼可以有无限层，每层都有各自的设施房间，比如83层是音乐厅，26层是豪华会客餐厅，38楼有大浴场，每层有一个专属负责的女仆。城堡是一个大型的场地，按照不同的楼分为几个区块的，每个区块有个总领女仆。在地面那层，楼与楼之间的空白区域是城堡的中庭，场景就用圣魔之血的那个广场，在比较高的空中层，楼与楼之间可以用回廊的形式连接起来，还可以有露天的空中庭院。最后城堡有一块后庭，有许多时空隧道通往其他大陆异世界浮游岛，隧道是异次元空间。想好城堡的边界是什么，如何控制玩家不出圈，边界做成怎么样的风景比较合理，skybox为永远的黑夜，想好合理的故事解释背景场地解释，想好玩家登录时从哪里降落，也就是城堡的入口在哪里。

how to save and load? how to save checkpoint and game data? UI system.
when working with UI or inventory, we need to pause the game sometimes (if single player mode). How to pause the game that meet your needs? This can be very tricky, be sure to study this:
https://gamedevbeginner.com/the-right-way-to-pause-the-game-in-unity/

画面左上角做一个游戏内的console，可以输入console命令做设置？可能需要用到SendMessage？这个console的功能一方面是给玩家提供游戏内高级设置，一方面我可以用来作为GM super user的测试窗口，通过输入秘籍指令灵活地调节一切游戏数据，玩家等级什么的，这样可以方便testing。不要自创命令和语言了，就用python。

关于Inventory，所有的Item都要定义成enum类型，比字符串要效率的多。至于玩家具体的背包和库存，用Dictionary来存储Item:Amount的键值对，便于查找。通常，玩家都希望自己的库存是有固定顺序的，可以自定义分类，所以最好用OrderedDictionary有序的实现。这样也方便可以一键点击自动重新排列。

所有的assets，要打包起来成为assetBundle，用最新的工具Unity Addressable Asset system管理，保证内存会自动释放不必要的素材，否则所有被reference过的素材材质都会一直堆积在内存里最后crash。

Cinemachine可以用来做timeline动画衔接多个virtual相机，可以考虑用于制作剧情中的平滑的cut scene（用多个虚拟相机）。先把场景人物搭起来，然后再去做一些cutscene作为场景衔接动画，以及片头动画。

用scriptable object来生成批量的gameobject，对于UI的图标什么的尤其有用。这种方式生成的每个go都是customized的，带有不同的属性。而对象池和它的区别是，对象池是为了性能原因提前生成go，cache在内存中方便反复使用，池子里每个go都是一模一样的基于同一个prefab生成。但scriptable object不是为了性能，而是为了开发的方便，给一群类似的go设计一个可以作为基础的模板，并没有放在cache里，且每个衍生出来的go都有各自的特色，当然也可以一样。在很多场景中，我们可以把scriptable object和对象池结合起来，配合使用达到需要的效果。

Cinemachine Brain的update method就用默认推荐的SmartUpdate就可以了，一般不会卡，除非出现了jitter（几乎不会）。smart在大多时候都是用LateUpdate的，确保物体全部移动好了再更新相机位置，除非target是一堆刚体在动画（比如带刚体的非kinematic NPC），且动画特别快幅度大特别复杂，这种情况下每次LateUpdate会有很多次FixedUpdate且动画幅度大，所以用FixedUpdate更准，否则动画可能会掉帧。正常游戏里不会有那么复杂的动画的。（记住LateUpdate是在所有update包括fixedupdate之后的）
Cinemachine Brain的最后一个toggle项Camera Activated Event，用于当两个虚拟相机blend切换时在第一帧触发自定义事件，该事件是个继承了UnityEvent类的自己写的C#的class脚本（参考CinemachineBrain的第113行源码）。比如两个NPC A和B对话，可以用来在切换AB的follow相机时blend的第一帧触发显示台词的对话框。（或者也可以在每个virtual相机的transitions选项中的OnCameraLive添加事件，也就是当该相机live的时候，也就是blend的最后一帧，其实这样效果更好，镜头对准了再显示对话框）

和女仆的对话窗口用Live2D插件来实现

按Q切换武器的时候，不要快速换枪一样，而是弹出一个UI的转盘，让玩家可以选择武器。

TO-DO-LIST：Cinemachine用的好的话，和Timeline两者完美结合，是可以用来做出很赞的film电影的，利用各种相机平滑切换，配合storyboard和BGM平滑切换。这块暂时不深究，但这是个亮点可以用来制作电影剧情。比如ARIA的场景，不光是让玩家自己自由以第三视角探索，而是制作一段小电影配上合适的BGM，试图来还原ARIA动漫原作中的一些感人怀旧场景，是非常不错的。再比如可以用来当做场景的intro片场finale片场以及中间剧情过场动画，比如当玩家发现某个幸福的宝藏时，进入某个场景时，先禁用玩家Input，播放一段上帝视角的预览动画，用音乐和情感色彩去渲染那种意境，让玩家更容易入境。对于静态的场景，可以在scene中手动设置dolly paths，也就是一系列的waypoint轨道，让相机沿着轨道移动，从而实现手持相机拍摄的效果。参考package自带的sample场景模仿就行了。

把游戏的各个不同的模块，用UML整理出来，有一个清晰的大局观。

光照的强度（比如天气），以及某些效果音和音乐的音量fade，可以用animation来做。
尤其是光，可以动画一盏路灯被风吹而摇动，同时灯丝blink，光照强度逐渐递减然后熄灭，又跳回来点亮，导致灯光flick闪烁和摇曳的效果。非常赞。

最后build的时候，在Unity中做好片头splash动画和logo，在project settings/player中设置default icon以及default cursor，用作游戏内的图标和鼠标图案。
build之前，把scripting backend从mono换成IL2CPP，确保C++ compiler设置为release，并启用Use incremental GC。平时开发的时候，不要启用Use incremental GC，虽然它能让GC分摊到很多frames里，从而避免profiler出现比较大的GC spike，但在开发过程中，这并不利于我们optimize做调优，反而会很容易忽略掉一些GC spike，所以一定要当所有调优都完成后，最后build的时候再选这个选项。build的时候，注意把project settings的quality设置好，目前开发为了流畅，我把默认的quality调成了low，build的时候要改成ultra，并且提高各种画质的选项。

用Cinemachine Confiner extension来控制TPS相机的边界，到了边界玩家还可以往前走但相机就不能了，所以玩家的背影越来越远，达到一定距离以后就可以切换场景了，用这个做场景切换的效果。所以也就是说，这个相机的confiner是个矩形，矩形的长宽要比scene的大小稍微小一圈，相差的那一圈也就是相机会看着玩家渐行渐远的那段距离。

游戏中设计几个观察者视角的场景活动，比如斗兽场里看女巫们对打，赌谁赢的画面，涉及到多个物体同时移动。然后用Cinemachine Target Group来实现同时让相机look at所有的女巫，随着战斗进行，女巫数量逐渐减少，相机就会自动zoom in。这是唯一可以实现look at多个物体保证在屏幕内的。

场景切换时要换BGM，利用音量逐渐减小fade的切换方式，用Timeline来实现。也可以用coroutine。

代码调优，enhance performance，读一下：
https://learn.unity.com/tutorial/fixing-performance-problems#
对于Performance-critical代码的调优，或者是速度非常慢的代码（比如语音，图像类操作），可以考虑写unsafe关键字的函数，用C#的指针来手动操作，配合fixed和stackalloc关键字，就和写C++一样，但是会涉及到类似C语言很底层的东西，通常不需要。当你用了unsafe关键字和指针，C#自带的GC就不会对这块代码起作用，因为GC本质上也是依靠智能指针来跟踪内存的，GC没法知道你有哪些指针，指向什么地址。

跑车移动的时候，后面加上trajectory render和nitro能量特效。

Calendar里面的日出日落月出月落函数，每天凌晨0点批处理时运行获取，用于schedule接下来的事件，比如触发Restopia城堡内的主钟声和钟摆动画。
GetManaDate用于在UI里显示当前Mana世界的时间，可以做全息日历什么的。
GetManaSeason获取季节，动态地调整地形的天气效果。Restopia之外的某些地图对此invariant，有独立的天气。
GetManaTime获取一天的时间段，如早晚中午等，根据这个时间段来调整Restopia内的mana浓度，午夜达到极值，某些场景的特殊魔法功能需要一定浓度才能触发。

电视机或电脑的屏幕，或者一些大屏幕的动态渲染，是用相机实现的。把camera的view投影在一个render texture上，然后把这个texture挂载到电视屏幕上或者一块石板上，该相机的view就都会显示在那个texture所挂载的gameobject上。相当于是创建一个可以播放camera view的动态texture。

用[NonSerialized] to make sure a variable state is reset to default on game state change. 如果一个变量比如motor里的groundingStatus，每一帧都在变化更新，同时它又是一个public变量需要在其他class里被访问的，就用NonSerialized，此时unity不会去序列化它，会让它每帧更新，而序列化通常代表着这个变量的值在play的时候就固定了不变了。换句话说，一个每帧不停在变的值不能被序列化，序列化只适用于runtime相对恒定的变量，通常一个每帧在变的值都是private变量，默认是NonSerialized的，偶尔这个变量又需要被其他class访问，所以是public，这时就要加上NonSerialized。其他的情况用HideInInspector.

某些level中，比如在建筑物内，设置一些房间，使其场景是其他level的场景（并不是穿越到另一个level，只是把那个level相同的场景copy过来）。比如某个房间，打开门结果到了一个梦幻的世界郊外（有边界）。这样玩家下次到达真实的该场景时，会反应过来这个地方我来过（实际上不是同一个地方）。

玩家初始1级有100点血和魔，每升一级加100，最高100级，血和魔上限9999.

when level/scene changes such as the player goes thru a portal, fade out the current game view, then switch to a UI canvas with progress bar, then fade in the new game view. use a script to control fading effect. Using coroutines。

MUSIC没有版权没关系，做成可以让玩家自行选择本地音乐文件的形式，每个人对于每个场景最适合什么音乐可能有不同的偏好，这样让他们自己去匹配自己最喜欢的场景氛围。ofc, the player has the option to choose if to play the music in a scene or not, there's gonna be a play/stop button. 至于我自己的版本，我发给其他朋友和测试者邀请他们一起玩的版本，由我自己事先选好音乐，这样不构成侵权，只属于私用，但要明确告知对方不可以在网上进行发布。
在游戏中runtime时选择本地音乐文件，弹出一个选择窗口，需要访问OS的fileSystem，这个是取决于平台的，比较难做，还好有现成的包，记得用Github收藏的Unity Standalone File Browser这个package。
MUSIC还有个办法，利用AI自动编曲，需要用到音乐人工智能的知识，具体到时候参考知乎收藏的文章学习一下，然后去咨询相关专业的答主，看能不能用现成的API或自己训练个模型，只要把我想用的原曲feed给这个模型，模型就会自动生成一段相同曲风的BGM（无法逆向工程的，这样就没人知道原曲是什么，不涉及任何版权问题，其实也可以在游戏里列出来原曲列表给玩家参考）
MUSIC的播放由场景自动触发，进入则开始播放，同时在画面右上角以“大图书馆的牧羊人”相同的方式，在一个半透明小文字框里显示当前所播放的曲目名称。

关于武器，主要武器是魔杖wand，同一根魔杖有多种技能效果，对应不同快捷键，每次触发时在update中instantiate粒子系统，无需使用对象池，但要设置boolean标记表示技能进入CD（update会判断bool标记），同时，下方UI技能框要显示技能CD的状态。每种技能的攻击速度范围都不同，直接在wand类中设置。由于有CD机制的存在，不用对象池，并且每次直接getcomponent也不会有性能问题。

关于升级系统、职业系统和技能树，有个最简单的办法，就是与现实世界的人类成长一一对应。职业分为理工科、文科商科（物理术士，数学术士，化学元素术士，商术士，文术士，格斗士，魔法使等等），升级是通过做题来完成的，在游戏中设置对应学科的习题，答案对了就获得经验值，达到上限就升级，可以获得新的技能和道具。为了游戏性，不要把题目出的很难太专业，而要有一定的趣味性，比如可以是很神奇的小学奥数题，脑筋急转弯，哲学讨论题，简单科普题，或是文学著作和逻辑经典书籍的摘抄什么的。

每个玩家有一个笔记本，功能和未来日记类似，每触发一定事件，笔记本上会自动记录一些文字，并提示音提示玩家。其实一开始笔记本里就有全部的故事text，只不过是逐条显示，每次readline一行，并保存seeker的位置状态，而不用去本地文件里每次读取。

语音系统完成之后，要在unity里实现3D效果，比如玩家在房间里说话，必须要有回声，模拟现实的声音而不只是麦克风。

实现一个动态加载地图的功能，用trigger collider做，当玩家靠近一定范围时，附近的房间内室才会load加载。

Unity C#

Mathf.PerlinNoise(float x, float y)对于相近的input会产生相近的output随机数，所以局部相邻的位置就看上去是连续的。可以把x,y看作是图上的一个pixel的坐标位置，相近的pixel就会有连续的值。但其实这个函数的input必须是小数，对于整数的input比如2.0和3.00这种，返回值是固定的，就不会有连续的效果。PerlinNoise的input被称作sample，因为你不会只调一次这个函数，而是连续不断的输入相近的input去调它，得到连续的噪音系列，所有的这堆input共同构成了一组sample，sample可以是一个数组，一个代表texture的二维矩阵，甚至是三维四维的超立方体。

Unity只提供了二维的这个函数，用于模拟二维平面上的perlin噪音，可以用来生成随机texture，比如做procedural的地形之类的。三维的怎么做不知道，比较困难。一维的很简单，只要固定input的其中一个，只变化另一个就可以了，比如固定x sample的值为0，变化y sample的值，那么相近的y值就会产生一系列看上去连续的随机数，在单个axis上模拟随机效果。考虑一个相机的shake，如果每一帧的input都非常接近，只相差0.01比如，生成的随机数也非常接近，那么只有当时间过的足够久，经过了很多帧，新的input相对于最开始的input才会有显著的差别，生成的随机数才会有显著的差别，也就是变化非常平缓smooth，模拟动画效果的话就是超慢动作；反过来如果每帧input差别较大，每帧的随机数也差别很大，那么动画每帧都在颤抖着变化position，但这样看上去动作就不再是连续的了，就失去了用perlin噪音的意义。因此，调整到合适的frequency非常关键，要让input每次变化相近，但又不是太接近，才能同时保证平滑连续和正常的动作速率。

关于爬梯子的设置，所有的梯子包括child全部设成Ladder layer，其中，root go加一个trigger的box collider用于检测玩家是否靠近，而每个child加一个正常的collider用于碰撞，使玩家不能穿模。top和bottom的release点，合理设置位置，尤其y方向要保持水平。top和bottom的anchor点，通过那条gizmo的线设置，保持那个vector离梯子的垂直距离正好够玩家摸得到，但又不会穿模。

asset完全可以在云端在服务器上，作为DLC的形式存在，这样app的size就可以非常的小，方便下载，等玩家需要用到asset的时候，再实时的下载DLC就可以了。对于公司来说，这样也便于未来游戏更新，再怎么加内容，都不会让app size变大。

Streaming Assets有点类似于Resources文件夹，整个文件夹会原分不动的copy到build中去，然后runtime时可以用StreamReader以stream流的形式读取，适合于视频文件或音乐BGM之类的非常大的文件。通过stream读取的形式，可以避免非常大的文件资源被一下子load到内存里，节省资源。不支持WebGL。至于build时具体被copy到哪个文件夹哪个位置，取决于target platform，对于windows mac linux ios android和console等等，位置都不一样。

Addressable是未来的主流，很强大，认真学一下。有了Addressable，很多东西都可以做成云端DLC的形式存在，StreamingAssets就基本没用处了。未来可以考虑用Unity自带的Cloud Content Delivery产品，可以免费有50个GB的云端存储，用于部署自己的游戏asset：https://unity.com/products/cloud-content-delivery

UI的Canvas是一切UI内容的容器，是最上层的一个container，所有UI内容都会被render在canvas里面，通常设置canvas的大小为scale with screen size并指定好分辨率。一个scene可以有多个canvas，用于不同的功能，都是on top of scene被render的，可以设置canvas的sort order，数值越大的会被最后render，所以会覆盖掉其他的canvas，比如loading screen就要设成999保证它永远在屏幕最前面。

Panel是Canvas下面一级的container，代表canvas中一块小区域，用于将canvas中的相关联的UI元素group起来，以此来有效分类和组织canvas的不同元素。在一个panel上，可以添加Canvas Group component，用于调节整个panel的透明度什么的。一个panel必须有且只能有一个graphics component，要么是Image，要么是RawImage，用于render这个panel。Image成分reference的是一个sprite，通常用于显示一张图片，比如loading screen的背景图，是静态的。RawImage成分reference的是一个texture，通常用于显示每一帧都在不断变化的内容，texture在runtime的每帧都在变。对于每帧变化的内容，sprite不适合，因为Sprite.Create()又慢又占内存。RawImage灵活度更高，接受任何Texture，提供更多动画和从代码中update的功能，而Image成分相对简单单一，只接受Sprite（Sprite只是Texture的一种）。大多数时候，我们用的都是Image成分，配合一个sprite，很少需要在UI中显示动态的内容的。

Texture的本质是bitmap，是用来贴在3D物体的mesh上用来render的。在Unity中，每个go的mesh renderer下面都要有一个material，通常一个mesh对应一个material，如果有submesh可以有多个material，而每个material都是由一个或多个texture加上shader所组成的，material是把texture和shader结合起来所构成的材质。bitmap就是一个二维矩阵，每个元素对应一个pixel，用来贴在其他物体上。有时候texture也可以是cubemap，即三维矩阵，用来贴在skybox上。

Sprite是一个2D的图形物体，相当于就是一个2D的game object，对应的mesh是flat平的，这个平的mesh上已经有texture了。Sprite是texture应用到go上的一种特殊形式，任何一个texture都可以转换成sprite。由于它的mesh是平的，Sprite是通过Sprite Renderer渲染的，而不是Mesh Renderer。

简而言之，texture是主要用来控制一个3D物体的外观的，而当你需要显示一张2D图片的时候，无论是动态变的还是静态的，永远是用sprite。

不过要注意一点，如果需要在runtime时load sprite，一定要把sprite提前创建好，导入图片后在import settings中设置好点击apply，对于大图这个要等上好几秒，但是之后runtime直接load它就很快了。如果一开始没有在import settings中apply创建sprite，而是直接runtime调用Sprite.Create()方法，虽然可行但是非常慢，要卡好几秒。

SetActive is for gameObjects（go）and enabled is for Components on the Object，所以我们我们设置active状态是针对gameObjects而言的，而当具体某个gameObject被active以后，在那个object的挂载的component脚本中，我们要用onEnable去判断（判断这个脚本component被enable了）。设置enable flag则是针对具体某个component而言的。换句话说，setactive是把一整个gameobject前面的勾打上或去掉，设置enable=true or false是把某个component前面的勾打上或去掉。

判断一个go是否active通常用isActiveInHierarchy，也就是说必须它的所有parent也active，否则只要有一个parent不是active，哪怕这个go本身是active，它也不会被update不会起作用。判断一个component是否enabled通常用isActiveAndEnabled，就是这个component对应的go首先要active然后它enabled才有意义，否则只看enabled为true并不代表这个component在起作用，很可能它attach的go是inactive的。

debug UI的时候，不用自己写log，可以直接点击Hierarchy窗口中的EventSystem go，然后在inspector的最下方就能看到eventsystem的实时debug信息表。

debug某个go的时候，往往我们也可以把Inspector切换成debug mode，可以直接动态地看到所有private变量的实时更新情况。

GameObject and all of its component exist before awake is called. This means you can call GetComponent in Awake(), 但是要注意，awake里面不可以访问你定义的变量，虽然可以访问任何component，但不能访问任何component的变量，包括本class的SerializeField变量。以下是best practice：

Awake: Here you setup the component you are on right now (the "this" object)

Start: Here you setup things that depend on other components.

当第一个Start被call的时候，整个游戏里所有脚本的Awake都已经运行完了。

如果一个go一开始是inactive的，awake和start都不会被call，只有当它在游戏中被active了以后，awake、start和OnEnable才会被调用。

【要注意的是】，awake被调用的前提是go为active状态，所以即使该脚本component是disabled的，只要它的go是active，awake也会被调（OnEnable则不会），而不是等到它OnEnable了才会被调（Awake is called even if the script is a disabled component of an active GameObject.）

melee combat用第三人称，ranged combat用第一人称。

创建一个preload scene是个好习惯，可以更简单方便的organize游戏资源，比singleton之类的lazy loading更好用。

preload scene主要用来生成那些persistent的go，service之类的，也就是整个session所有scene都必须的组件。

可以考虑用splash screen scene来作为preload scene，实现一样的功能。

如何carry数据across scenes？？？

    https://gamedev.stackexchange.com/questions/110958/what-is-the-proper-way-to-handle-data-between-scenes

playerPrefs是用来存放游戏的配置数据的，是游戏的Preferences数据，比如音量分辨率之类的，而不是用来存游戏数据的。playerPrefs采用的是最简单粗暴的方法，把这些settings数据全部存储为string，没有任何序列化操作，不方便管理，且当数据较大时难以scale，因此不要用playerPrefs来做save/load系统，仅仅只是存储游戏的settings设定和玩家preference而已！！！

在游戏session中，存放数据用ScriptableObject，SO非常灵活，可以方便的carry数据across scenes，但是SO只在当前session内存活，当application退出后SO的数据就没有了，所以可以用ISerializationCallbackReceiver来写自己的custom序列化逻辑，application quit的时候会序列化调用这个callback，就可以手动把游戏数据保存到本地，然后下次打开游戏的时候再从本地load数据到SO里。序列化就用简单的File I/O来做，利用Unity自带的JsonUtility class。

怎样合理的load new scene并且unload current scene？

如果new scene场景不大，比如进入另一个房间或战斗场之类的，直接additively在后台异步地load new scene就好了，load完成了再unload current，则会自动切换到new scene。记得要用异步的LoadSceneAsync方法，一般都不要用load single scene的LoadScene函数。

如果两个场景都很大，比如一般的主场景切换，additive的模式会把两个同时load进内存，这对memory要求很高，不是个好的选择。最好的做法是，每次主场景切换的时候，中间都做一个loading screen作为过渡的场景，显示图片和一个进度条。由于loading screen非常的小，所以additve没问题，先load这个过渡场景，好了之后unload当前场景，然后再load新场景，好了之后unload这个过渡场景，也就是做两次这个动作。这样就可以无缝切换了。

SceneManager.sceneLoaded是用来指定当新场景load好之后需要call的callback，但不要乱用，不好追踪。大多数事情不需要放在这里面去做，在新场景的go的Awake或者Start里面做就行了，最好是game manager里做，这样设计更清晰。sceneLoaded的callback是在新场景的awake之后执行的，并不是最开始跑。只有当涉及到一些需要跨scene的逻辑，比如move某些go到新场景什么的，才有必要放在sceneLoaded里面。

如果你确定某个go或component不会被destroy，那么判断它是否为null时，用!ReferenceEquals(go, null)，相比而言，!=null非常昂贵。

NonSerialized主要是用来避免序列化一个变量，于是Unity或其他Json或二进制序列化不会包含这个字段，也就是在任何data打包传送的过程中，此字段都会被忽略。（比如，clone或instantiate一个go时，unity就会需要去序列化该go；还有当unity想要把脚本里的字段显示在editor中，也必然有个序列化反序列化即save/load的过程）。一般来说，私有变量用private就可以，如果又想保护数据以防被改，又想被其他类访问到，就用[NonSerialized] public（当然也可以为这个字段专门设一个public getter property，但很麻烦也未必适用，property是用于专门为了给其他类访问的变量用的，预计会被频繁访问，如果只是偶尔有可能会被访问到，还是NonSerialized合适）。再有就是比如一些c#无法存储的texture/bitmap之类的变量，不应该也不能被序列化，就要用NonSerialized。通常NonSerialized最常见的用法，还是为了保护某些字段的数据，而这些字段又偶尔可能会被访问到所以无法设成private。

anchor是一个UI元素的Rect Transform相对于它的parent的Rect Transform的位置。anchor中的min max值，指的是anchor相对于parent Rect Transform的位置，是一个百分比例，当parent的scale发生变化时（切换分辨率），anchor的值能够保证anchor相对parent永远处于同一个位置，比如水平30%垂直50%等等。同样的，pivot的值也是一个百分比，指的是pivot在当前UI元素中的相对位置。

在UI元素的Rect Transform中，POS X Y的值，指的是该元素的pivot距离anchor有多远。当pivot和anchor重合时，pos x y永远为0.

在调UI的时候，不要直接去改POS X Y的值，先确定好anchor和pivot的位置（最好用九宫格Rect Tool），然后有必要了再去改POS，否则一团糟。

Destroy(gameObject);                 // Removes the go, all its components and children

Destroy(this);                       // Removes this script instance from the game object

Destroy(GetComponent<Rigidbody>());  // Removes the rigidbody from the game object

DestroyImmediate();                  // 千万不要用，非常危险！！！可能会删除你的prefab和其他asset！

PhysX的重力加速度是常数，默认9.81，可以在脚本中通过Physics.gravity.y访问，也可以在Physics project settings中设置。对于某个特殊的scene比如月球场景，可以在loadScene时把Physics.gravity设置成Vector3(0, -4.9f, 0)，即地球的一半，不过要记得换场景时设回-9.81f。

实现一个物体在两点之间来回bounce，有几种方法。首先是Mathf.PingPong，像乒乓球一样反弹，然后还可以用两个方向相反的lerp族函数，使得反弹平滑，再有就是利用三角函数sin,cos，利用sine wave自然的平滑性质，并且可以自己调节wave的形状和频率参数，实现各种效果。但最直观最平滑的办法是用animationCurve，在脚本里加一个animationCurve的serializeField，然后在inspector里拖动成想要的曲线形状，代码在update中可以通过animationCurve.Evaluate(Time.time)来实时获取该曲线当前的float value，这样就可以实现任何形式的曲线效果。

vanilla version, code smell, boilerplate code vs template, overhead...

Unity不支持多线程，你可以在自己的纯C#脚本里用多线程，但不能在monobehavior class里用多线程，因为多线程脚本是无法访问任何Unity的API的（因为Unity的API并不是线程安全的）。同时，在你的纯C#脚本里，也要小心保证用到的都是.net的线程安全的函数。这是不是代表Unity很没有效率？不是：

Unity的内部还是有很多地方用到多线程的，比如scheduling，job system，audio，网络通讯，mesh skinner等等，只不过Unity不允许开发者在与Mono相关的game-level的代码中使用多线程，这是为了保证Unity内部的多线程状态稳定。但我们其实还是可以在纯C#脚本中使用多线程，比如可以用来跑后台的批处理什么的。实际中最常见的用例是：处理文件IO读写，处理网络通讯，计算pathfinding等等这些和mono独立的部分。这些功能如果要实现的话，完全不需要和Unity挂钩，而是应该做成单独的模块，在普通的.net solution里开发和测试好，再直接提供数据给Unity使用。

除了这些比较重大的模块之外，我们在开发时最可能会用到多线程的地方，就是Unity自带的Job System，具体参考文档。这是唯一一个我们可以按照Unity规范来安全的使用多线程的地方，但其实用的还是Unity的API，多线程是发生在底层的，Unity自动帮我们处理并发问题，我们只要会schedule job就好了。注意别schedule太多。

https://docs.unity3d.com/Manual/JobSystem.html

要注意一点，Unity自带的coroutine和多线程没有任何关系，只是让你产生好像是多线程的错觉而已，本质还是在一个core上运行的，由CPU调度计划以interleaved的方式执行代码，而并没有涉及到任何线程之间的context switching（上下文切换很expensive），所以才很light-weight。

对象池的池子用Dictionary+queue的数据结构来存储，可以提高查找性能，比如预生成150个子弹+200块石头，那么Dictionary就有两个键值对，{'子弹':queue()}, {'石头':queue()}，key是某类go的tag字符串，value是存储该类go的一个队列。这样设计，每次fetch的时候传入一个tag，就不需要遍历数组了，直接O(1)时间找到该类tag所对应的queue，然后也不需要遍历queue，直接Dequeue()弹出第一个对象即可，将其设为active，再重新Enqueue()入队到最后。如此一来，每次fetch都只用O(1)的时间来完成，最效率。之前我用的是array数组，每次要遍历才能找到一个inactive的对象，返回它再将它设成active，很慢，而且一旦数组的对象全部用光了，所有对象都是active的，那么就fetch不到了。而利用queue的想法是，每次直接弹出第一个，不管它是不是active，都设成active，再马上重新入队到最后，然后直接使用它的reference，这样就不会出现池子被用光的情况，哪怕queue里所有对象都是active了，fetch也会弹出第一个（也就是最老的最早被active的那个），然后去复用它，如此不断循环。当然其实这不会出现，因为在使用的时候，我们就要预估好用量，保证预生成的池子足够用，同时还要在该对象的prefab上挂好脚本处理OnEnable的逻辑，保证对象在被active后，过几秒马上就会inactive回收，而fetch是由Input触发的，哪怕是negev连发每秒也最多几十次，fetch的速度应该是跟不上回收的速度的。

ObjectPool的脚本要挂载在枪、魔杖或其他武器的发射口上，这样生成的子弹的parent直接就是武器本身，且position和rotation直接就是parent的值，不用再去做运算，然后直接给子弹ammo的刚体加一个初速度，最后再start一个coroutine去在几秒后回收它。

对象池的设置，每个prefab生成多少个amount，这个是要根据不同的对象去fine tune的，要在游戏中具体测试下，才能找到最优的amount，正好够用又没有浪费。具体测试的时候，用最大速度连发，然后盯着Hierarchy窗口，如果发现对象全都active，说明数量不够，如果最后几个对象始终是greyed out的，那么就够用了。

我的对象池是通用的，只管预生成object，并在被fetch的时候active一个返回给caller，而不需要去关心caller拿到对象后去做什么。对象始终都在池子里，只不过active状态会变而已。对象本身的脚本，负责实现各种方法以及何时回收，而caller则是负责何时去调对象的方法。对象池自己并不关心这些，它假定caller和对象自己会处理好一切，在短时间内一定会回到inactive的状态。如果出现了问题，不会是池子的问题，要么是caller和对象自己的class没处理好，要么是生成池子的时候amount太小数量不够。

可以给每个自己写的脚本，甚至每个gameobject设置自定义的icon图标，这个很有意思，可以方便我们辨别不同的脚本。

https://forum.unity.com/threads/gamemanager-cs-icon.539596/

如何在一个脚本里调用另一个脚本的方法？比如player有一个TakeDamage的方法，而游戏中很多其他物体都可能call它，不光是enemy还有地形效果和buff和item效果等等。最直接的办法是在每个可能会是caller的脚本里，设置一个SerializeField变量来拖拽存储player的go，这样就能利用这个变量直接call，但是如果call的地方太多了呢？比如TakeDamage非常通用，到处都在call它，每次都这样设变量在编辑器里拖拽，又麻烦又杂乱，设计很糟糕，那怎么办？

UnityEvents是用来存放一堆functions的容器，在editor中可以拖拽不同的function进去，告诉某个脚本要执行哪些event，显然不是用来干这个的。

SendMessage已经不适合现在的版本了，不要使用，性能慢且design很差，BroadcastMessage也是同理。除非？画面左上角做一个游戏内的console，可以输入console命令做设置？可能需要用到SendMessage？

那就只能GetComponent了，但是一定要每次都这样做吗？有没有更好的办法？

想了下，应该是没有的。因为这种情况下，你call的那个方法如果不是static的话，必然是在某个已经生成的class instance上call的，所以无论如何都需要有一个该instance（在Unity中也就相当于player go）的reference，如果不拖拽hook up上，那就只能用findWithTag这种更慢的办法了。如果你想把那个方法wrap封装一下，在别的地方随意call，也是不可能的，因为能随意call的只有class的static方法，对于非static方法，是不能把它封装成为static的。换句话说，想要有universal的调用方式，那么必须是针对static方法，而依赖于某个go或instance的方法是无论如何也做不成universal的。试想一下，在playerManager里，playerController已经被成功的hook上了，你想一劳永逸，写个方法PlayerTakeDamage()，在里面去操作在playerController，然后想让外面能随意call它而不用重复hook playerController，这是不可能的，因为要达到这个目的的话，PlayerTakeDamage()必须是static的，而一个static函数体内，是不能access非static的东西的，所以矛盾。换个角度想，这样的设计其实并不糟糕，或者说这样才对，因为在任何一个会deal damage的go上，都应该显式的有一个damage receiver，才符合逻辑。

反正是单机游戏，只有一个player，用singleton也是可以的，而且playerStatus只管理玩家数据而已。或者干脆就用一个static class算了，但是那样的话没法save和load，不适合序列化。这个设计的问题，解决方案不仅要考虑到player数据可以单例的全局访问，还要考虑到怎么序列化save load，怎么persist between scenes。

ScriptableObject也是global access的，可以是singleton的一个很好的替代。

------------------------------------------------------------------------------------------------------------

GetComponent<T>()是generic泛型的版本，返回的直接就是该泛型T(就是某个class的类型，比如某个script的class名字)，然后可以直接操作调方法了。

GetComponent(typeof(someType))返回的是component，用于获取某个component。通常我们是要对someType的方法进行操作，所以用之前还需要先cast一下：(someType) GetComponent(typeof(someType))。显然，用generic的版本更加便捷。

if (x > 10) { _animator.setBool('Walk', true)}  // don't write like this

_animator.setBool('Walk', x > 10)  // nice one

Vector3? point = ...  // type后面的问号代表这个变量可能是该type，也可能是nullable type

------------------------------------------------------------------------------------------------------------

TextMeshPro的text不要直接修改，如果每次都给text赋值一个新的字符串，每个update都要产生待GC的垃圾，其他UI text也是同理。用TextMeshPro.SetText()方法可以避免不必要的垃圾，该函数有多个版本，而且还可以使用StringBuilder作为参数。对于Timer这种主要是数字的text，最底层的garbage-free的办法是用TextMeshPro.SetCharArray()方法，传入一个char数组，但要手工update每个char，有点麻烦。事实上不用麻烦，就用SetText就可以了，看了下源码，SetText里面就是用的SetCharArray，内部有一个唯一的char数组，每次只会更新变动的char，不过要保证用的是带arg的版本，SetText(string text, float arg0, float arg1, ...)，而不是SetText(string text, bool syncTextInputBox = true)这个会产生垃圾的版本。

Time.fixedDeltaTime是一个常数，和游戏FPS无关，可以在project settings里面设定，默认是0.02f。Time.fixedDeltaTime并不是两个FixedUpdate call之间的间隔时间，这点非常容易搞错，不管是Update还是FixedUpdate，间隔时间都是Time.deltatime。

还有个很大的误区是以为FixedUpdate is called at fixed time steps，因为它名字里有个fixed，然而实际上并不是，这个fixed与现实世界的时间没任何关系，并不是每隔fixed时间间隔就会被call的，具体的频率由Unity决定。FixedUpdate只用于simulate Physics，不要把其他的每x秒更新的逻辑放在FixedUpdate里，不要在FixedUpdate中使用任何非Physics的代码。

MonoBehavior是个类，但首先是个Behavior，是控制go在unity中如何behave的类，我们通过inherit它来写自己的behavior，这些behavior是通过component的形式来实现的，然后用component来操纵游戏中的go。所以可以说，我们主要是面向component编程的，component是Unity游戏主要的架构模式，component总是和go紧密关联在一起。问题在于，大量的go和component在切换场景的时候，重新load的时候，是要被destroy的，非常的零散，而且无法persist across scenes。所以在大局观上，MonoBehavior并不是用来存放数据的地方，只定义我们的行为。

ScriptableObject虽然也是继承mono的，但它不与任何的go或component或prefab关联，自带序列化功能，适合包装和存放数据，并且能share across scenes，也很便于transfer到其他项目。ScriptableObject适合用于存放player或enemy的数据，然后在mono的行为脚本里，我们可以去reference它，把数据和行为的代码分离。还可以用来存放inventory的数据。甚至是整个场景的level data，配合上JsonUtility的序列化功能。到时候看看save load用这个怎么样。

LateUpdate() is called after all Update functions have been called but before redrawing the scene，记住a follow-camera should always be updated in LateUpdate！！

C#有自带的Timer和Stopwatch类，时间可以非常精准，当处理precision critical逻辑比如数据库和登录时间的时候，都要用这两个。但是在Unity中，还是用我自己写的那几个包括cooldownCounter的类，因为游戏里的event要和Unity的Time.deltaTime等时间挂钩，需要根据time scale和FPS变化而变化，而不应该参照绝对的系统时间。用C#自带的Timer类的话，是没办法处理time scale的问题的，哪怕我们永远不会设置游戏的timeScale，始终用默认值，也无法保证Unity的timeScale和绝对的系统时间是同步的，无法保证该timeScale和现实世界的同步率为1.

有些脚本的名字是Unity保留的关键字，比如Folder，Audioclip，GameManager，Search之类的，当你创建一个同名的脚本时，Unity会自动给它一个图标。这对游戏本身没什么影响，但是和Unity自带的保留的功能可能会冲突，解决办法很简单，把你的脚本代码用一个namespace包起来，只要你用的是自己的namespace，而不是global的全局的namespace，就不会出现这个问题。

什么时候用abstract类，什么时候用interface，结合设计模式去考虑。

前者是is-a的关系，后者是has-a的关系。前者是inherit的关系，可以用virtual和override，后者是implement的关系，可以提供多个规范。

https://stackoverflow.com/questions/747517/interfaces-vs-abstract-classes

https://stackoverflow.com/questions/14728761/difference-between-virtual-and-abstract-methods

对于任何member包括method，property，event，indexer而言，virtual可以被override也可以不被，只是提供了override的option，但abstract必须被子类implement。当rider提示你你的某个method或者property hide隐藏了一个同类的member，可以用new关键字来明确指出你希望hide。

Unity的event function比如Awake和Update，在abstract类中要设置成protected virtual，让子类选择性的去override它，or not。而对于property，通常设置为protected abstract，强制子类去提供具体实现。

tag是用来处理批量的go的，如果某个tag只有一个go用，就显得有些没必要，但实际上这是为了性能，因为Find函数（通过name find）非常慢，会搜索全部scene的每一个go，但是findWithTag函数是优化过的，findGameObjectsWithTag也一样，只不过是返回所有该tag的go。使用tag时，脑子里先把go干净的分好类，想好tag，否则后面很乱会很难改。如果实在要find一个go，比如事先不知道该go在哪儿，或是该go要在游戏中后面才会生成，那么findWithTag是最优的选择，然而！！！通常我们都知道要找的是哪个go，所以其实可以不用在脚本里find，直接定义一个SerializeField变量，提前在编辑器中拖拽hook up上就行了，这样比findWithTag还要快很多，而且还能减少场景加载时间。

singleton模式要慎用，一个singleton的instance被创建以后，因为是在class内被instantiate的，所以它在程序运行时就永远存在而不会被gc掉。如果有很多个singleton，就会不必要的占据固定的内存。什么时候用呢？如果你需要一个class的实例数据，且该instance是在整个程序全局需要被共享的，且整个程序全局只能有一个该类的instance时，可以用。比如说，实现一个全局的GameManager，是全局共享的且只能有一个。再比如，单机游戏只有一个玩家，且玩家的数据本来就是要永远存在的，且游戏中各种地方都会去调用玩家的TakeDamage方法，那么玩家的class就可以做成singleton。数据库和服务器这种庞大的对象，虽然也是全局共享的单例，但千万不要做成singleton，会很占内存。而对于不大不小的全局共享对象，要不要做成singleton是看情况的，用了则会占用内存，但减少了CPU读写开销，不用的话省内存，但每次读写就会更消耗CPU，所以本质上是一个balancing act，在内存和CPU中间找平衡取舍，如果读写十分频繁的话，舍弃点内存节省CPU消耗还是很不错的。

singleton可以persist across scenes，不管有多少个scene，都能共享同一个singleton。

在Unity中使用singleton，还要额外注意，因为要继承monobehavior的话，没法保证singleton只有一个instance，哪怕构造函数的private的，我们依然可以在editor里拖拽脚本来创建多个singleton的实例，或者用Instantiate函数来创建实例，想避免这种情况，就要非常小心。

C#的internal关键字和C++的friend友元类似，但可能是个code smell，用的时候考虑好。Unity中不用考虑这么复杂，必须用到了再说。

Code smells are usually not bugs; they are not technically incorrect and do not prevent the program from functioning. Instead, they indicate weaknesses in design that may slow down development or increase the risk of bugs or failures in the future.

conversion和cast是完全不同的，所以(int)x和Convert.ToInt32(x)有本质的区别，但这个问题极其复杂，具体用到了case by case搜一下。。。

c#里面的struct是value-type而不是reference-type，因此不能修改struct里某个field的值。class类型以及C#9.0新推出的record类型都是referene-type，而原始类型比如int，float，string这些是value-type，这很好理解，但要注意struct也是value-type，不能当成class用，另外还有tuple也是的，所以tuple或struct一旦被创建，就是一个内存里的常量值，不能修改某个field，想修改变量的值必须要创建一个新的struct或tuple。这点和C++是不同的。In practice，struct臭名昭著有很多坑，尽量避免使用，如果要用的话，一定要用immutable版本的struct，定义readonly struct，以防出错。

不过Unity自带的Vector3是可以直接修改x,y,z的值的，因为它们并不是raw field，而是被封装好的public property，当你修改的时候它的setter会自动new一个新的vector3，对于Quaternion以及Matrix4x4也是一样的。

Input在水平和垂直的axis上的值对于键盘和手柄通常是-1到1之间，0代表没动，只有鼠标的移动是例外，可以在（-1，1）区间之外。GetAxis会返回(-1,1)之间的一个浮点数，做过smooth处理了，步长是0.05f，但GetAxisRaw没有smooth和步长，所以值只会是-1、0、1三者其中之一，没有浮点数。

通常，我们计算速度时，是看Input的绝对值的，也就是0-1之间的一个值，再乘以一个multiplier和deltatime，如果xy两个axis同时按住input，走斜线是根号2，要比单独一个axis速度快，所以为了速度平衡，记住一定要做normalize处理。

normalize和clamp的区别是什么？normalize返回一个向量的unit单位向量的copy，模为1，换句话说，被normalized了以后，模永远是1。而clamp可以返回比1小的浮点数，0-1之间都可以。考虑一个从原点出发的单位球，一个normalized的向量永远只能触碰到球体的表面，却无法触碰到球体内部，但是clamp则可以触碰到整个球体空间内的任何一个位置，不止限于表面。所以通常情况下，用clamp，不要用normalize，对于单个浮点数，就用Mathf.Clamp，对于向量Vector2,Vector3,Vector4，用对应类的静态方法去clamp，比如Vector3.ClampMagnitude().

speed是一个标量scalar，是一个具体的float数值，velocity是一个向量Vector3，两者不要混淆。

Vector3.Equals用于判断两个vector3（可以是点或向量）是否完全相等，这很少会用到。一般用的都是Vector3重载的==符号，比如transform.position == other.position，这会判断这两个position是否近似相等，考虑了浮点数的精度误差，差值小于1e-5则认为相等。

the amount returned by Mouse X/Y or the scrollwheel can vary heavily from device to device so it's common to provide a sensitivity setting for the user to adjust. (use a [HideInInspector] public float sensitivity variable, which can be changed via the UI system later in-game) 这个设置后面加在UI里，让玩家可以自己调节，不要放在inspector里。

如果KCC就算设置了step height也爬不上某些楼梯，很可能是浮点数精度的原因。稍微resize一下capsule collider即可，只要height（默认2）不是radius（默认0.5）的4倍就行了，可以把圆柱体的height调成1.1.

如果就算在UpdateVelocity里更新了ref currentVelocity的值，KCC也没有反应没有移动，也是浮点数精度的问题。如果速度的xyz分量太小的话，KCC是会忽略的，改成0.01或以上的数量级就好了，三位小数0.001这种会被认为是0。

KCC的character站在普通的物理驱动的刚体上，也是可以跟着移动的，但是永远会慢一个frame，这样就有jitter。只有加上physicsMover才能看上去平滑，因为KCC系统内部是严格定义了physicsMover的execution order要在character之前。我的movingPlatform脚本是支持timeline动画的，一般的moving物体都可以用动画来实现复杂的movement，本身再带刚体，那么就可以和KCC完美的交互。如果一些moving物体必须是由physics驱动的，比如海上的一艘船，船的translation和rotation是在runtime的时候由复杂的水的physics决定的，那就必须在船上加上physicsMover component以及一个movingPlatform的脚本，通过脚本的UpdateMovement函数去告诉physicsMover当前的goal的position和rotation是多少，其实也就是当前船的tranform的pose。

root motion VS scripting motion

scripting motion是指character的movement完全由controller的代码所100%控制，程序员对movement有完全的自由掌控。

root motion是指character的movement由动画所决定，动画play的同时人物会move，可以是自动的，也可以手动通过OnAnimatorMove()来获取动画的movement。

如果你希望input的控制十分流畅灵敏，movement又十分复杂，比如FPS射击这种对精度要求高的游戏，用scripting motion比较好，此时，character的movement和动画是完全独立的，动画只是in-place的动画，动画本身只在原地animate人物但并不产生实际的movement。在代码里，先指示人物如何move，然后再在合适的地方更新动画的参数，play相应的动画。scripting motion的缺点在于，脚本控制的movement和动画是独立的，所以没法完美同步，在不同的速度下，walk和turn之类的都会出现细微的不协调，比如walk时看上去character的foot像是在地面上slide一样。好处是这样做更安全，有更多control，并且把movement和动画完全分割开来，workflow也更清晰，不会有两者互相干涉而产生的bug，最主要的，长远来看这是一个长期投资，如果你未来可能会给character controller加更多更复杂的功能，这个方法的扩展性很好。

如果你希望动画和movement完美协调，画面动作看上去十分自然realistic，那只能用root motion。此时，代码就不能自由控制人物的movement了，而是要在OnAnimatorMove()的callback中获取animator的deltaPosition以及deltaRotation property，根据delta的信息算出实时的速度和旋转，再update人物，以保证完美同步(每一次update loop，动画都可能会loop一次或多次，所以OnAnimatorMove要accumulate)。root motion的缺点在于，由于完美同步，动画必须要做的十分精准才行，否则有任何微小的震荡，都会反应在movement上，另一方面，如果你的character运动需求特别复杂，那么就要求动画也要同等的复杂精准，这是很麻烦的，毕竟用代码控制movement要比用动画去控制简单的多，这也导致了未来的可拓展性不高。而root motion最大的弊病在于，由于动画的transition是需要时间的，这会使input的反应有一定延迟，降低controller input的灵敏度和responsiveness。

root motion和scripting motion的区别，对比一下CSGO和DOTA就知道了，CSGO的操作要求鼠标的反应绝对的灵敏精准，那么人物就自然没法和现实中一样特别realistic，而DOTA则要求英雄人物的动作和施法非常逼真，对操作的精准度没有太高要求，比如火女的T为了施法动作逼真就会有个抬手动作，导致施法前摇而不是瞬发的，比如屁股大的英雄会有明显的转身时间。通常，scripting motion用于FPS类游戏，root motion用于RPG类游戏。

最好的方案是，取两者的长处结合起来，blend在一起使用。对于玩家人物的普通移动等操作，用scripting motion，而在战斗模式中施法和攻击时，切换为root motion(否则攻击时玩家永远是在原地，但事实上挥舞刀剑什么的通常伴随着玩家向前移动一小步，受到攻击的动画会向后退一步，等等)。对于NPC这类AI人物，因为不是玩家自己主动control的，所以不存在要求精准度和responsiveness的情况，统一都用root motion来实现比较好。

简化需求！不要追求和现实一样极致完美，游戏的重点在于故事线和探索世界而不是玩家本身的动画。

通常玩家只要现有的controller行为和动画就足够了，不需要和现实一样遵循各种物理。本身KCC就是kinematic的，也就代表着我们自己handle一切的物理，而不用Unity自带的物理引擎，所以想要完美模拟各种runtime的物理动作并不现实，有基本动画即可。哪怕是玩家被车撞飞，利用AddExtraVelocity并加上瞬时的camera shake就可以实现了。

Ragdoll就是在骨骼的各个部位加上刚体和collider，像个物理人偶一样，用于自动和physics交互，可以实现十分逼真的物理效果，如果要用Ragdoll的话，去买商店的PuppetMaster素材包，这个package可以无缝平滑的衔接现成的动画和physics，无缝切换。

另外，FinalIK是同一个studio出品的IK的包，可以和PuppetMaster配合使用，但其实没必要，我只要简单的让玩家头部在auto模式下能follow某个NPC就好了，这种最基本的功能，直接用Unity自带的animation rigging包就可以完成了。

除非是在auto模式下做cutscene动画需要一些逼真的动作，或者是控制NPC的动作，才需要这些工具，用到了再说。买素材考虑下价格，最好花钱在刀口上，还是主要以买世界模型的素材为主。NPC不要用KCC controller去操作，只要用timeline做现成的动画+NavMesh，顶多配合上最基本的Ragdoll物理，加上一点点IK，就足够满足需求了。

【处理IK有几种不同的方法】

最底层的是自己手工代码处理，在animator的base layer上勾选IK Pass，这样animator就会自动的去call OnAnimatorIK的方法，所以只要在同一个go上挂个脚本，该脚本里实现OnAnimatorIK()的逻辑，设置好IK target的position/rotation以及weight，就OK了，但是target的position/rotation并不容易计算，比如玩家爬楼梯或者走在坑洼的地形上或者slope上，哪怕脚的着陆点可以向下做raycast算位置，但脚还有长度的，想正确计算脚的rotation，需要做多个raycast，还要考虑到character的velocity以及character的transform up方向，非常复杂。还有就是，哪怕正确计算了target的信息，效果未必好，因为rigging的处理完全是由Unity自带的Mecanim操作的，也就是animator控件在控制的，对比下Final IK可以看到，Mecanim处理rigging并不是很自然，还是有不少问题的，这块自己又控制不了。

利用Animation Rigging package，在editor里设置好IK constraint以及target还有rig，那么Unity会自动帮你处理好IK，这个包对于rigging的处理要比原本的Mecanim的animator好的多，但你还是要手动去update target的位置和旋转，如果只是简单的让Humanoid的头部look at某个target还比较简单，但foot IK还是很难算位置和旋转，而且也是要自己处理好collision什么的。重点就是不知道这个包是不是稳定，毕竟还在preview，就算发布了也还很naive，需要时间的考验。

用付费的Final IK包，目前Final IK是最好的asset，不需要自己手动算位置旋转，全部帮你自动解决，挂个component就好了。功能强大且丰富，功能最全，经过多年许多人的测试考验。缺点是90刀打对折也还是很贵，除非需要实现很复杂的IK，否则不要买。另外，未来的话，官方的Animation Rigging包会是大趋势，早晚会替代final ik。

【SOLUTION】长远来看，还是要自己熟悉这块功能和逻辑，目前只需要foot IK和Aim IK，但随着游戏变复杂，其他的像是人物拿杯子喝水，开门什么的，用IK可以做的非常漂亮且realistic，现在还是要认真学习和熟悉一下。从程序员成长的角度，最好是自己去踩坑，用方法1，自己手工写代码实现全部，那么以后用别的package也会更顺手。目前的话，先买那个便宜的素材，把里面的代码全都研究一遍，再改成自己的，过几年等Animation Rigging包稳定了，把一部分逻辑切换过去。

做动画是一件非常复杂困难的任务，表面上看只要每一帧去调整不同骨骼的pose就好了，但其实想要实现高质量的动画，即使有VeryAnimation和Umotion这种插件工具，tune的过程非常麻烦，很难做出理想的效果。也正是因为这样，所以会有专门的animation artist这个职业，专职做各种3D动画。想要自己实现tech48那种动画，Unity里是不可能做得到的。专业的artist都会用第三方的专业动画制作软件，例如龙骨，spine，3dmax这些软件，专门有一堆做动画的工具。尽管如此，一个复杂的动画还是很困难，网上找职业artist代做动画，行情也基本上是10秒钟的动画就要20刀。所以，目前很多技术都在往mocap的方向发展，也就是motion capture，当然价格很昂贵，比如Radical是用AI自动从视频中解析出动画数据，8刀1分钟，还有xsens推出了一套穿戴式的传感服装设备，人穿上了就可以实时录制动画，要10000刀，再有就是iclone 7这种高级软件，可以做各种专业的电影级别动画，也是上千刀起。

如果是做一般的不太复杂的动画，尤其是generic类的，或者简单的humanoid动作，可以在unity中用VeryAnimation以及Umotion插件。如果要做丰富的humanoid动画，不要自己浪费时间，行不通的，哪怕是下载mixamo的动画再自己修剪，也很难，还是要去找现成的素材asset，或者外包给第三方。对于动漫类3D character的动画，想要比较可爱的动画效果，还是要去找日本的素材和外包，有需要了多搜搜看。

Unity.Mathematics一定要配合Burst使用，单独用的话比mono还要慢。DOTS要用就一起用，这样才能提高性能。

如果发现animation的transition很奇怪，人物的脑袋会变形，那是因为你的animator里指定了mechanim的controller。用Animancer的时候，要确保animator里的controller为None(Runtime Controller)才可以。

当你发现某些运动的物体和player交互的过程中出现了jittery，有几个点可以检查。首先如果它是通过animation运动的，检查一下animation的Update Mode是否正确，可能要用AnimatePhysics选项，或者对于UI物体要用unscaledTime选项。再者，看一下它的刚体是否开启了interpolate，如果没有的话，当physX和玩家update的fps速度不一致时总会出现jittery。

Random.insideUnitSphere  Random.rotation

kinematic animated的物体是没有速度的，velocity永远为0，尽管它们在运动。所以必须手动计算，用deltaPosition和deltaTime做除法。非kinematic的运动物体，是由physX控制的，我们总是可以通过刚体访问到它的velocity属性。

Mathf是Mono针对C#本身的Math库做了一个简单的封装，性能上是没什么差别的，原生的Math库是基于double类型操作的，Mathf库是基于float类型操作的，所以才叫做Mathf。Mathf的很多方法，其他类也有同名的方法，只是操作对象类型不同，换句话说，很多方法除了Mathf的版本之外还有其他版本。比如Mathf.SmoothDamp是对一个float进行平滑更新，对应到向量，则可以用Vector3.SmoothDamp，功能是完全一样的只不过是操作向量。Mathf还有Lerp和LerpUnclamped这种插值函数，同样的，对于其他类型，我们也有Vector4.LerpUnclamped，Quaternion.LerpUnclamped等等。

如果是在PS4 XBOX这种console上玩的话，电视屏幕要大的多，必须要把相机的FOV调到100以上，测试完了再build。如果是VR设备的话，要更大才行，这个就比较复杂了现在不考虑，有些VR会自动重新计算FOV的。

相机的near clip记得设成一个比较小的值，比如0.01，否则相机obstruct的时候，会出现render黑框的情况。far clip根据scene的景深调节。

几种平滑和插值的比较：

Lerp is linear, works well for very fast movements, is less demanding on CPU，但是在首尾两端的移动会很sudden不平滑。

SmoothDamp follows a sigmoid function, looks more like the object is accelerating and decelerating, is more pleasant to the eye.

Slerp or Spherical Lerp is generally only applied to Quaternions, or at least vectors, not positions.

我们还可以设计自己的平滑函数，用sine和cosine wave就是很好的例子，它们定义域无限，而且还能调节amplitude和频率，还能配合clamp产生反弹效果等等。



Mono format是单音轨，Stereo format是双音轨（左耳右耳），普通的音频都选force to mono，比如人物对话，UI音之类的，而BGM音乐和ambience音，以及cutscene和某些特效的音频，选stereo。

PCM是所有音频最终输出时候的目标格式（codecs），是lossless的格式，处于完全解压uncompressed的状态，占用内存大小等同于源文件original size。

ADPCM是一个压缩过的compressed格式，在Unity中，占用内存大小要比PCM格式小3.5倍，即大约是源文件大小的30%。压缩后最好试听一下失真的程度（一般听不出）。

Vorbis是比ADPCM更好的压缩格式，算法复杂，同等压缩大小下的音质更高，同等音质下压缩的更小，但当play的时候，解压会占用很大的CPU。

MP3是和Vorbis同等级的一个压缩格式，算法也很好，但MP3 cannot loop seamlessly，所以为了loop的衔接音质，一般prefer用Vorbis。

---When to load audioclips to memory：

【Preload Audio Data】 【load in background】

[Y] [Y] 只要该AudioClip在scene中被reference了，那么Unity会在load scene的同时load这个AudioClip，但load audio不会block主线程。scene加载好了就会进入play mode，剩下还没加载好的audio会在后台加载。

[Y] [N] 只要该AudioClip在scene中被reference了，那么Unity会在load scene的同时load这个AudioClip，没reference则不会load. load不会在后台发生，因此会block主线程，只有当audio也load好了以后，scene才会进入play mode。（最好的）

[N] [Y] Unity只有在该audio被调用到(play)的时候才会load，哪怕场景里有reference它。会消耗CPU，但不会block主线程，所以音效的defer可能会造成不同步。

[N] [N] Unity只有在该audio被调用到(play)的时候才会load，哪怕场景里有reference它。不仅消耗CPU，且会block主线程来load，所以虽然不会造成音效不同步，但可能会出现卡帧（frame hitch or frame freeze）。

更换场景的时候，Unity会自动在garbage collect的时候unload之前的audio，清理内存。

对于重要的SFX，都要在import的时候给Preload Audio Data打上勾。loading只占用加载场景的时间，不影响gameplay，所以多等一会儿没事儿，只要内存占用不过分。

---How to load audioclips to memory（Load Type）：

Decompress on Load：load音频的时候就顺便解压成目标PCM格式并放入内存中了，占用更多的内存，但不再消耗CPU，可以随时play。选了这个选项，音频在内存中的大小就是original size显示的数字，而不是imported size。适用于反复地频繁使用的较小的音频，如footsteps，攻击音效，UI按钮音等等。

Compressed in Memory：load到内存的时候，在内存中依然保持压缩的状态，直到被play的时候才会解压。占用内存较小，但play时需要先消耗CPU来解压。play结束后，解压过的数据就会消失，下次再play时还要重新消耗CPU来解压。适用于不太经常会被用到的，偶尔才会play的音频。

---streaming

音频不会被load到内存，只有在play用到的时候才会当场从磁盘读取数据，放入内存，再解压。因此，平时完全不占用一点点内存，但play时CPU会瞬间飙升。适用于size最大的例如BGM和环境音这种音频文件。

一言以蔽之，音频的问题就是，在文件大小（占用内存大小），runtime CPU消耗，以及音质三者之间寻找平衡。。。。。。



关于coroutine：

yield return null;  // wait until the next frame (temporarily return, then continue execution in the next update)

yield return new WaitForSeconds(5f);  // wait for a period of time

WaitForSeconds delay = new WaitForSeconds(3f);  // cache the WaitForSeconds object for repeating delays

yield return delay;

...

yield return delay;

yield return new WaitForSecondsRealtime(5);  // uses unscaled time

yield return new WaitUntil(IsEmpty);  // pauses execution until a bool delegate/lambda function evaluates to true

yield return new WaitWhile(() => fuel > 0);  // waits for a bool delegate/lambda function to be false before proceeding

yield return new WaitForEndOfFrame();  // waits until the frame is ready

yield return StartCoroutine(OtherCoroutine());  // Wait for another Coroutine

Coroutine co = StartCoroutine(MyCoroutine());  // don't use the string version, store it in a var if u wanna stop it later

yield break;  // end from inside of a Coroutine

StopCoroutine(co);  // end from outside of a Coroutine, don't use the string version

StopAllCoroutines();  // stops all Coroutines started by this script, even if the Coroutines are in another script.

                      // e.g. if script A starts coroutines in script B, this must be called in A, but does not work in B.

Coroutines end themselves once they complete.

Coroutines are tied to the Game Object that called them, so destroying/disabling the go will end any Coroutines that were called from it, even if they're in other scripts on other gos, but disabling the script won't stop it since the go still exists. If a Coroutine on go A was called by a script in go B, destroying/disabling go A won't end the Coroutine.

Coroutines只是一种multitasking的便捷处理方式，但并不是多线程，其实还是在单线程里以interleaving的方式跑的，主要用于拆分逻辑，适用于轻量的小函数。Coroutines是UnityEngine特有的一个封装的函数，没有返回值。

Async/Await才是真正的多线程异步，是C#原生的语法，是non-blocking的，适用于重量的运行时间长的routines，且可以有return values。功能更强大，支持一切代码，且不会有内存leak的问题，难点在于要手动处理concurrency避免race conditions。相比之下，Coroutines如果挂载的go被意外或不当地destroy，会有内存泄露。

游戏内的小逻辑，fire-and-forget的routines就用Coroutines处理就够了，增加可读性。但对于例如数据IO传输、网络层通讯这种重要功能，一定要用Async/Await。

// invoke函数也可以达到同样效果，但性能和灵活度不如coroutines，尽量避免使用。

// invoke的对象方法只能接受最多一个参数，有限制。而StartCoroutine(MyCoroutine(arg0, arg1, arg2, ...))随便来几个参数都可以。

Invoke()  // delay a function call

InvokeRepeating()  // delay a function call and repeat it every x seconds

------------------------------------------------------------------------------------------------------------

Rider里对于已经build过的脚本文件，原来还可以查看IL（CIL中间语言）代码，相当于汇编，可以用鼠标查看每个命令的含义什么的用于调优。

You can multiply the Quaternion and the Vector3 and you'll get back a Vector3 that has been rotated by that Quaternion:

Vector3 rotatedDirection = transform.rotation * direction;

TransformPoint vs TransformDirection vs TransformVector

https://answers.unity.com/questions/1021968/difference-between-transformtransformvector-and-tr.html

When using coroutines for physics calculations be sure to use WaitForFixedUpdate NOT WaitForUpdate.

Keep your game within 6000 units of the origin.

Keep your forces below 10,000 Newtons.

Keep your masses bellow 10000 kg and above .01 kg.

Unity allows many objects to have the same name, but every object has a unique Instance ID.

It is good practice to include an object's instance ID as well as its name in debug statements:

Debug.Log(go.name + ":" + go.GetInstanceID());

Instance ID非常容易获取，对于任何一个go，只要点击它的Inspector的右上角（lock图标旁边），将normal切换成debug进入debug mode，那么Inspector就会自动显示出每个component的Instance ID，同时还会显示出脚本里的private变量（灰色的，只是显示，不能修改）的最新值。在debug模式下，如果脚本里的某个方法前面标注了[ContextMenu("...")]，还可以直接right click那个脚本component，在菜单中选择那个方法的名字，于是该方法就会被手动的调用一次，这样我们可以很方便的看到方法是不是起作用了。

Vector3.Distance(a,b) is the same as (a-b).magnitude，性能上几乎一样，通常不用纠结，除非是循环做几万次这个操作，具体哪个快取决于CPU的FPU（floating point coprocessor），要在不同的设备上试一试。如果是比较两个向量的长度（模），不要用magnitude，而是去比较模的平方，比较Vector3.sqrMagnitude，这样减少了两个开根号的操作会更快，因为Mathf.Sqrt是比较复杂的，比乘法慢很多。比较时千万不要用==判断，因为浮点数是有精度问题的，要用Mathf.Abs(x,y) < episilon。

飞行时加上翅膀。这个先不做，等把玩家的character替换成哥特萝莉了再加上。翅膀必须是humanoid avatar的一部分，并且被包含在飞行的animation clip中。平时翅膀处于disable状态，没有collider。当动画进入flystate的时候（而不是kcc进入air mode），再通过OnEnable和OnDisable进行开关，同时开启collider。
为了模拟翅膀从后背逐渐长出来的效果，不要直接设置enabled的flag，而是start一个coroutine，从翅根的部位把mesh的透明度一点点设置为1。同时，翅膀自带一个trail renderer，最好是用particle做的，翅膀完全伸展开了以后，开启翅膀go上的trail renderer的开关（脚本控制emitting为true or false）。

VRoid做自己的哥特萝莉，白丝，黑色圆头萝莉皮鞋，黑色连衣裙，奈叶式法杖，名字叫？？？。retarget Satomi的动画到她身上。另一套装束是，水蓝色连衣裙，白丝，加一个银色的脚环，红色高跟鞋或者把shirley放到blender里改一下？学习blender的基础做成texture可以换装的，runtime替换skinnedMeshRenderer。

为什么slope太逗的话，会从move进入airborne？？？难debug，以后再看。实在不行就把太陡的slope边沿前面加个box collider。

walk up/down stairs，没有animation，有了animation再补。楼梯上不准run只能walk，给每个楼梯设置一个trigger collider，在KCC里处理。
crouch的动画play的时候，脚会陷入地面，要么修改animation，要么用IK解决。

TPS的时候，crosshair的rotation要clamp在一定范围内，保证玩家的look at ik动画看起来正常。
FPS的时候，玩家自动随着crosshair旋转，所以无所谓。
做IK！！！！！参考animancer的例子和买的素材。==============================================================
https://forum.unity.com/threads/foot-ik-system-without-weight-curves.470853/
爬楼梯就用普通的walk动画，但是要计算好脚落地的位置，不要在台阶的ledge上。
人物的脚步声，jump声，各种动画音效加上。用animancer的event实现。

到此。base layer全部搞定。

combat layer，做上半身的简单武器动画，melee attack有三个combo（全连需要root motion，在KCC里已经写好了，目前注释掉了），没有block动作。
range attack就是几个简单施法动作，加上crosshair（固定距离）以后，以crosshair为target做aim ik。有防御阵魔法替代block。
(参考Animancer的layer example和IK example，可能还要看下event的example)

aim IK以及让手臂自然的去follow抓住镰刀，用animation rigging在editor里设置好，再配合OnAnimatorIK()去更新处理。
foot IK参考那个素材，重写素材，自己用OnAnimatorIK()处理。
Shirley，平时走路不带翅膀和镰刀，进入飞行状态的时候，动画展开翅膀并启动镰刀，镰刀相当于是飞行的扫帚。如果需要战斗，必须先按键，把镰刀拿出来，分两种模式，近战把镰刀动画变大，可以挥舞造成物理伤害，但无法使用魔法，也没有准星。远程攻击的话要把镰刀动画变成手可以握住的魔杖大小，粉水晶的部位用粒子系统或者shader graph做个动画特效，用于蓄力施法的，但远程状态下无法物理攻击。
飞行或游泳状态下如果需要战斗的话，只利用翅膀进行飞行，而镰刀用于战斗。
近战模式下，TPS的rotation调成和FPS一样，人物随着鼠标的转动而转动，不能朝向相机往后跑，只能后退，所以要有个后退的动画。
远程模式下，做个准星，准星用UI-gameobject模式实现，并设置为上半身IK的target。同时，左右键改成左右的strafe移动，而人物不转向。

【XXX】继续刷CatlikeCoding的教程。先把所有教程过一遍，不用实现，只理解知识内容。后面肯定要回来过第二遍的。过完了第一遍，会有个更完整的大局观，对接下来的开发会有提速的效果。争取两周之内刷完，只要阅读和在atom里记笔记就行了。

【XXX】--------------做Quantum Console，这个改一下demo素材就好应该很快的！！！
【XXX】--------------是时候把地图换掉了，快看吐了。开一个新的project把HDRP试一下，不卡的话，把Crest Ocean的水和easy road和Gaia的demo scene导入两个不同的scene，用HQ Portal切换场景，然后把skybox换成allsky的素材，用一些买的mesh effects。或者先学一下catlikecoding的SRP管线再说，看能不能custom一些东西。不要用URP，URP虽然性能很快，比default还快，但是只适合mobile和2D游戏，我早晚都是要用HDRP的。
传送门统一用蓝色半透明，除非是特殊地图的特殊入口。传送门有个abstract类的脚本，定义传送门的基本功能，其中包括一个property存储传送目的地（可以为多选），另一个property CanTeleport定义传送是否是allowed。每个传送门都挂一个脚本去implement这个抽象类，CanTeleport取决于玩家的等级、故事线触发等条件。每个传送门都有个trigger collider，当玩家进入范围时触发OnTriggerEnter，如果CanTeleport为true，传送门变为绿色，否则变为红色。

【增加feature】当站在旋转的平台上时，人物要随着平台一起旋转和移动，FPS时camera带动人物旋转，TPS时camera不旋转只follow。利用新写的那个MovingPlatform的脚本。测试一下motor上的rigidbody interaction type的选项。----暂时取消，等新的DOTS Strider CC出来了重写，新的CC非常强大。
【增加feature】导入car controller，实现人物开车的功能，camera要根据车子的晃动而shake。
【增加feature】用KCC控制AI，参考example的AI脚本。----暂时取消，等新的DOTS Strider CC

【fix】planet目前的逻辑是通过teleporter的进入而改变gravity的，把这个扩展一下，当玩家靠近星球一定距离的时候，OnTriggerEnter就改变gravity。
【增加feature】搭第一版简易地图，导入HDRP包和相关素材，搭建旋转的planet(用planet脚本)以及teleporter。

【开发UI系统】
学习Unity UI 1.0.0 （UGUI），学习购买的MMO UI 11。
最新的官方【UI Toolkit】还在开发preview阶段，暂时观望。近几年还是以UGUI为重心。

【fix】refine loading screen的loading bar，自己写脚本替代掉UI自带的那个很丑的slider，用MMO UI 11包里现成的progress bar素材。
【增加feature】切到UI界面，或者弹出UI菜单的时候，要启用鼠标cursor。Cursor.visible = true; Cursor.lockState = CursorLockMode.Confined;
【增加feature】飞行状态时，做个meter的radial表盘F3显示高度和速度，没找到素材，等学了Photoshop再看，表针划过的区域用shader做成半透明的彩色状态。

【开发战斗系统（动画和IK已经做完了）】
先学习视频，确定好架构和设计！！！！
https://www.youtube.com/watch?v=FGVkio4bnPQ   // 工厂模式
https://www.youtube.com/watch?v=nqAHJmpWLBg   // 基于reflection的比较高级的C# Architecture from Jason
https://www.youtube.com/watch?v=G1bd75R10m4   // State Machine
这个SO的unite talk非常专业，花一周时间研究一下怎么做architecture，用SO替代掉传统的singleton和unity event。
https://www.youtube.com/watch?v=raQ3iHhE_Kk
melee combat用第三人称，ranged combat用第一人称。就算是TPS视角，也要在屏幕中间加一个很淡的crosshair（当鼠标移到攻击对象身上时，动态高亮）
然后，开始研究设计怎么和序列化搭配！！！！把SAVE LOAD的功能和存储数据的方式（数据库或简单文本等等）实现出来！！！！
然后，开始搞仓库系统！！！试试看scriptable object。
学习ScriptableObject Tutorial and Template:
https://www.raywenderlich.com/2826197-scriptableobject-tutorial-getting-started
https://www.youtube.com/watch?v=HQNl3Ff2Lpo
https://www.youtube.com/watch?v=SmnjRCa_iO4&t=71s
https://www.youtube.com/watch?v=LdlKiKC6mr4
https://learn.unity.com/tutorial/introduction-to-scriptable-objects#5cf187b7edbc2a31a3b9b123
等玩家的系统做好了，修改controller，让玩家在free模式中飞行的时候每秒消耗一点魔法。一旦mana耗尽，就自动切回default状态，可能会摔死。
在editor里，玩家的hp mana这些属性，用naughtyAttributes的ProgressBar做，看上去更直观。

【增加feature】战斗时可以按Q，弹出一个radial的圆形UI菜单，供玩家切换武器。

【save load系统】json序列化
https://www.youtube.com/watch?v=4h2CvULKqic

【升级到2020 LTS版本，春季发布】
【fix】把标注了【C# 8.0 feature not yet supported】的注释全部拿掉，替换之前的非switch expression语法版本。

成就系统：
Observer pattern实现游戏内的成就system，当玩家完成一定数量的kill或什么的，给予manacoin的奖励什么的，或者解锁某些功能，通过UI提示来反应。
https://www.youtube.com/watch?v=Yy7Dt2usGy0

----------------------------------------------遥遥无期----------------------------------------------
【增加feature】学习新的Input System包，创建InputAction asset，然后用新的input系统把动画和KCC脚本以及相机整合在一起。最好等DOTS Strider出来再说。

【Strider发布】把现有的KCC换成新的DOTS Strider controller，并把default/auto/climb/swim/air几种模式的架构改掉。现有的controller是一个差不多1000行代码的单个脚本，所有的controlMode都集中在一起，用一堆switch-case切换，虽然不影响performance，但是design非常bad，可读性较差，且改起来没那么方便。有了Strider以后，把每个controlMode放到一个单独的脚本里，每个controlMode都是有限状态机里的一个state，然后有一个“brain”脚本去管理所有的state以及state之间的transition。这样的话我的character controller就分成多个脚本，可读性很好，每次改只要改一个controlMode所对应的state就可以了。
【DOTS发布】 把整个项目migrate到DOTS版本，摒弃传统的OOP和monobehavior，采用ECS的data/code隔离的方式refactor代码。
现阶段Burst编译器和ECS包还有很多bug，以及非常多未完成的feature。

【未来扩展】用脚本控制Shirley的表情，比如按F2时从默认逐渐blend到生气，https://docs.unity3d.com/Manual/BlendShapes.html
【未来扩展】用animation rigging，参考Brackeys视频加上headAim rig，使得FPS的头部随着相机转动，水平正负100度之内，垂直正负90度。TPS不转动。
【未来扩展】实现动画的IK，以及人物换装，以及Target Matching【https://docs.unity3d.com/Manual/TargetMatching.html】这几个功能比较难，很大，目前阶段不好学，太占用时间了，而且只是微调的精细小功能，不值得现在花太多时间。

网络部分太麻烦了，以后再说：
研究一下kinematicCharacterController中的network部分，看一下如何手动控制simulation和setTick，处理网络的延迟模拟

addressable太难了，先跳过吧，估计要花两周时间啃下来。。。下面是一些教程链接。重点过一遍github那个仓库的sample，理解代码，然后再看视频。
https://github.com/Unity-Technologies/Addressables-Sample/tree/master/Basic
https://www.youtube.com/watch?v=6IlIA2eLk0I
https://www.youtube.com/watch?v=U8-yh5nC1Mg
https://www.youtube.com/watch?v=uNpBS0LPhaU&t=432s
https://gamedev.stackexchange.com/questions/169977/what-am-i-suppose-to-use-instead-of-unity-resources-if-i-have-to-load-and-unload

利用cinemachine和timeline制作并测试一下玩家的cutscene，利用default到Charging state的转换。






